C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE BOX_BSP
OBJECT MODULE PLACED IN .\Objects\box_bsp.obj
COMPILER INVOKED BY: D:\ProgramData\keil5\C51\BIN\C51.EXE box_bsp.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\box_bsp.lst) TABS(2) OBJECT(.\Objects\box_bsp.obj)

line level    source

   1          #include "box_bsp.h"
   2          #include <string.h>
   3          #define BUFFER_SIZE 16
   4          #define STATE_BUFFER_SIZE 3
   5          
   6          char busy;
   7          unsigned char buffer[BUFFER_SIZE];
   8          
   9          unsigned char rec_byte;
  10          unsigned char led_state;
  11          unsigned char Dev_address;
  12          unsigned char lock_vector;
  13          char j;
  14          unsigned char state_buffer[STATE_BUFFER_SIZE];
  15          int open_lock_timer = -1;
  16          int key_set_on_time = -1;
  17          int key_open_on_time = -1;
  18          
  19          void Timer0_Init(void) // 1毫秒@12MHz
  20          {
  21   1        AUXR |= 0x80; // 定时器时钟1T模式
  22   1        TMOD &= 0xF0; // 设置定时器模式
  23   1        TL0 = 0x20;   // 设置定时初始值
  24   1        TH0 = 0xD1;   // 设置定时初始值
  25   1        TF0 = 0;    // 清除TF0标志
  26   1        TR0 = 1;    // 定时器0开始计时
  27   1        ET0 = 1;
  28   1      }
  29          
  30          void TM0_Isr() interrupt 1
  31          {
  32   1        if (key_open_on_time >= 0)
  33   1        {
  34   2          key_open_on_time++;
  35   2        }
  36   1        if (key_set_on_time >= 0)
  37   1        {
  38   2          key_set_on_time++;
  39   2        }
  40   1        if (open_lock_timer >= 0)
  41   1        {
  42   2          open_lock_timer++;
  43   2        }
  44   1      }
  45          
  46          void led_set(unsigned char state)
  47          {
  48   1        unsigned char led_state = ~state;
  49   1        LED_GROUP_0 = led_state & 0x01;
  50   1        LED_GROUP_1 = led_state & 0x02;
  51   1        LED_GROUP_2 = led_state & 0x04;
  52   1        LED_GROUP_3 = led_state & 0x08;
  53   1        LED_GROUP_4 = led_state & 0x10;
  54   1      }
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 2   

  55          
  56          unsigned char getKeyGroupState()
  57          {
  58   1        unsigned char temp = 0x00;
  59   1        temp |= KEY_GROUP_0 ? 0x01 : 0x00;
  60   1        temp |= KEY_GROUP_1 ? 0x02 : 0x00;
  61   1        temp |= KEY_GROUP_2 ? 0x04 : 0x00;
  62   1        temp |= KEY_GROUP_3 ? 0x08 : 0x00;
  63   1        temp |= KEY_GROUP_4 ? 0x10 : 0x00;
  64   1        return ((~temp) & 0x1F);
  65   1      }
  66          
  67          void UartInit(void) // 9600bps@12.000MHz
  68          {
  69   1        SCON = 0x50;  // 8位数据,可变波特率
  70   1        AUXR |= 0x40; // 定时器时钟1T模式
  71   1        AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  72   1        TMOD &= 0x0F; // 设置定时器模式
  73   1        TL1 = 0xC7;   // 设置定时初始值
  74   1        TH1 = 0xFE;   // 设置定时初始值
  75   1        ET1 = 0;    // 禁止定时器中断
  76   1        TR1 = 1;    // 定时器1开始计时
  77   1      }
  78          
  79          void GPIO_init()
  80          {
  81   1      
  82   1        CHW_0 = 0;
  83   1        CHW_1 = 0;
  84   1        CHW_2 = 0;
  85   1        CHW_3 = 0;
  86   1        CHW_4 = 0;
  87   1        CHW_5 = 0;
  88   1        CHW_6 = 0;
  89   1        CHW_7 = 0;
  90   1        CHW_8 = 0;
  91   1        CHW_9 = 0;
  92   1        CHW_10 = 0;
  93   1        CHW_11 = 0;
  94   1        CHW_12 = 0;
  95   1        CHW_13 = 0;
  96   1        CHW_14 = 0;
  97   1        CHW_15 = 0;
  98   1        CHW_16 = 0;
  99   1        CHW_17 = 0;
 100   1      
 101   1        CHR_0 = 1;
 102   1        CHR_1 = 1;
 103   1        CHR_2 = 1;
 104   1        CHR_3 = 1;
 105   1        CHR_4 = 1;
 106   1        CHR_5 = 1;
 107   1        CHR_6 = 1;
 108   1        CHR_7 = 1;
 109   1        CHR_8 = 1;
 110   1        CHR_9 = 1;
 111   1        CHR_10 = 1;
 112   1        CHR_11 = 1;
 113   1        CHR_12 = 1;
 114   1        CHR_13 = 1;
 115   1        CHR_14 = 1;
 116   1        CHR_15 = 1;
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 3   

 117   1        CHR_16 = 1;
 118   1        CHR_17 = 1;
 119   1      
 120   1        KEY_GROUP_0 = 1;
 121   1        KEY_GROUP_1 = 1;
 122   1        KEY_GROUP_2 = 1;
 123   1        KEY_GROUP_3 = 1;
 124   1        KEY_GROUP_4 = 1;
 125   1        KEY_OPEN = 1;
 126   1        KEY_SET = 1;
 127   1      
 128   1        SYS_LED = 0;
 129   1        RS485_RX;
 130   1      
 131   1      
 132   1      
 133   1      
 134   1        P0M0 = 0x00;
 135   1        P0M1 = 0x00;
 136   1        P1M0 = 0x00;
 137   1        P1M1 = 0x00;
 138   1        P2M0 = 0x00;
 139   1        P2M1 = 0x00;
 140   1      
 141   1        P3M0 = 0x00;
 142   1        P3M1 = 0x00;
 143   1      
 144   1        P4M0 = 0x00;
 145   1        P4M1 = 0x00;
 146   1        P5M0 = 0x00;
 147   1        P5M1 = 0x00;
 148   1        P6M0 = 0x00;
 149   1        P6M1 = 0x00;
 150   1        P7M0 = 0x00;
 151   1        P7M1 = 0x00;
 152   1      
 153   1      
 154   1      }
 155          
 156          void Drain_set(unsigned char gpio_pin, unsigned char set)
 157          {
 158   1        switch (gpio_pin)
 159   1        {
 160   2        case 0x00:
 161   2          CHW_0 = set;
 162   2          break;
 163   2        case 0x01:
 164   2          CHW_1 = set;
 165   2          break;
 166   2        case 0x02:
 167   2          CHW_2 = set;
 168   2          break;
 169   2        case 0x03:
 170   2          CHW_3 = set;
 171   2          break;
 172   2        case 0x04:
 173   2          CHW_4 = set;
 174   2          break;
 175   2        case 0x05:
 176   2          CHW_5 = set;
 177   2          break;
 178   2        case 0x06:
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 4   

 179   2          CHW_6 = set;
 180   2          break;
 181   2        case 0x07:
 182   2          CHW_7 = set;
 183   2          break;
 184   2        case 0x08:
 185   2          CHW_8 = set;
 186   2          break;
 187   2        case 0x09:
 188   2          CHW_9 = set;
 189   2          break;
 190   2        case 0x0A:
 191   2          CHW_10 = set;
 192   2          break;
 193   2        case 0x0B:
 194   2          CHW_11 = set;
 195   2          break;
 196   2        case 0x0C:
 197   2          CHW_12 = set;
 198   2          break;
 199   2        case 0x0D:
 200   2          CHW_13 = set;
 201   2          break;
 202   2        case 0x0E:
 203   2          CHW_14 = set;
 204   2          break;
 205   2        case 0x0F:
 206   2          CHW_15 = set;
 207   2          break;
 208   2        case 0x10:
 209   2          CHW_16 = set;
 210   2          break;
 211   2        case 0x11:
 212   2          CHW_17 = set;
 213   2          break;
 214   2        default:
 215   2      
 216   2          break;
 217   2        }
 218   1      }
 219          
 220          unsigned char feedback_read(char gpio_pin)
 221          {
 222   1        unsigned char temp;
 223   1        switch (gpio_pin)
 224   1        {
 225   2        case 0x00:
 226   2          temp = CHR_0;
 227   2          break;
 228   2        case 0x01:
 229   2          temp = CHR_1;
 230   2          break;
 231   2        case 0x02:
 232   2          temp = CHR_2;
 233   2          break;
 234   2        case 0x03:
 235   2          temp = CHR_3;
 236   2          break;
 237   2        case 0x04:
 238   2          temp = CHR_4;
 239   2          break;
 240   2        case 0x05:
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 5   

 241   2          temp = CHR_5;
 242   2          break;
 243   2        case 0x06:
 244   2          temp = CHR_6;
 245   2          break;
 246   2        case 0x07:
 247   2          temp = CHR_7;
 248   2          break;
 249   2        case 0x08:
 250   2          temp = CHR_8;
 251   2          break;
 252   2        case 0x09:
 253   2          temp = CHR_9;
 254   2          break;
 255   2        case 0x0A:
 256   2          temp = CHR_10;
 257   2          break;
 258   2        case 0x0B:
 259   2          temp = CHR_11;
 260   2          break;
 261   2        case 0x0C:
 262   2          temp = CHR_12;
 263   2          break;
 264   2        case 0x0D:
 265   2          temp = CHR_13;
 266   2          break;
 267   2        case 0x0E:
 268   2          temp = CHR_14;
 269   2          break;
 270   2        case 0x0F:
 271   2          temp = CHR_15;
 272   2          break;
 273   2        case 0x10:
 274   2          temp = CHR_16;
 275   2          break;
 276   2        case 0x11:
 277   2          temp = CHR_17;
 278   2          break;
 279   2        default:
 280   2            temp = 0x01;
 281   2        }
 282   1      
 283   1        if (lock_vector==0x01)
 284   1        {
 285   2          temp = !temp;
 286   2        }
 287   1        return temp;
 288   1      }
 289          
 290          void get_state_buffer()
 291          {
 292   1      
 293   1        char i, j, temp;
 294   1        for (i = 0; i < STATE_BUFFER_SIZE; i++)
 295   1        {
 296   2          temp = 0x00;
 297   2          for (j = 0; j < 8; j++)
 298   2          {
 299   3            temp |= (feedback_read(i * 8 + j)) << j;
 300   3          }
 301   2          state_buffer[i] = temp;
 302   2        }
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 6   

 303   1      }
 304          
 305          void put_stack(char dat)
 306          {
 307   1        char i;
 308   1        for (i = 0; i < BUFFER_SIZE - 1; i++)
 309   1          buffer[i] = buffer[i + 1];
 310   1        buffer[BUFFER_SIZE - 1] = dat;
 311   1      }
 312          
 313          void UART1_Isr() interrupt 4
 314          {
 315   1        if (TI) // 发送中断标志位判断
 316   1        {
 317   2          TI = 0;       // 清中断标志
 318   2          busy = 0;     // 发送标志位置0，表示满足发送条件
 319   2          SYS_LED = !SYS_LED; // 测试端口
 320   2        }
 321   1        if (RI) // 接收中断标志位判断
 322   1        {
 323   2          RI = 0; // 清中断标志
 324   2      
 325   2          SYS_LED = !SYS_LED; // 测试端口
 326   2          rec_byte = SBUF;
 327   2      
 328   2          put_stack(rec_byte);
 329   2        }
 330   1      }
 331          
 332          void UartSend(char dat)
 333          {
 334   1        while (busy)
 335   1          ;
 336   1        busy = 1;
 337   1        SBUF = dat;
 338   1      }
 339          
 340          void BOX_Init()
 341          {
 342   1        GPIO_init();
 343   1        UartInit();
 344   1        Timer0_Init();
 345   1        P_SW2 |= 0x80;
 346   1        ES = 1;
 347   1        EA = 1;
 348   1        delay_1s();
 349   1      
 350   1        Dev_address = IapRead(0x0000);
 351   1        lock_vector = IapRead(0x0001);
 352   1        if (Dev_address == 0xFF&&lock_vector==0xFF)
 353   1        {
 354   2          IapErase(0x0000);
 355   2          IapProgram(0x0000, 0x00);
 356   2          IapProgram(0x0001, 0x01);
 357   2          Dev_address = IapRead(0x0000);
 358   2          lock_vector = IapRead(0x0001);
 359   2        }
 360   1      
 361   1      
 362   1      
 363   1        WDT_CONTR = 0x27; // 使能看门狗,溢出时间约为1s
 364   1      
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 7   

 365   1        while (1)
 366   1        {
 367   2          WDT_CONTR = 0x37;
 368   2          loop();
 369   2        }
 370   1      }
 371          
 372          void Delay1ms() //@12.000MHz
 373          {
 374   1        unsigned char data i, j;
 375   1      
 376   1        i = 12;
 377   1        j = 169;
 378   1        do
 379   1        {
 380   2          while (--j)
 381   2            ;
 382   2        } while (--i);
 383   1      }
 384          
 385          void delay_1s()
 386          {
 387   1      
 388   1        unsigned int i;
 389   1        for (i = 0; i < 1000; i++)
 390   1        {
 391   2          Delay1ms();
 392   2        }
 393   1      }
 394          
 395          void delay_500ms()
 396          {
 397   1      
 398   1        unsigned int i;
 399   1        for (i = 0; i < 500; i++)
 400   1        {
 401   2          Delay1ms();
 402   2        }
 403   1      }
 404          
 405          void delay(int ms)
 406          {
 407   1        unsigned int i;
 408   1        for (i = 0; i < ms; i++)
 409   1        {
 410   2          Delay1ms();
 411   2        }
 412   1      }
 413          
 414          void key_scan()
 415          {
 416   1      
 417   1        //====================
 418   1        if (KEY_OPEN == 0)
 419   1          if (key_open_on_time == -1)
 420   1            key_open_on_time = 0;
 421   1        if (KEY_OPEN)
 422   1          if (key_open_on_time == -2)
 423   1            key_open_on_time = -1;
 424   1        if (key_open_on_time > 500)
 425   1        {
 426   2          key_open_on_time = -2;
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 8   

 427   2          if (KEY_OPEN == 0)
 428   2            open_all_lock_key();
 429   2        }
 430   1      
 431   1        //====================
 432   1        if (KEY_SET == 0)
 433   1          if (key_set_on_time == -1)
 434   1            key_set_on_time = 0;
 435   1        if (KEY_SET)
 436   1          if (key_set_on_time == -2)
 437   1            key_set_on_time = -1;
 438   1      
 439   1        if (key_set_on_time > 3000)
 440   1        {
 441   2          key_set_on_time = -2;
 442   2      
 443   2          if (KEY_SET == 0)
 444   2          {
 445   3            IapErase(0x0000);
 446   3            IapProgram(0x0000, getKeyGroupState());
 447   3            IapProgram(0x0001, lock_vector);
 448   3            Dev_address = IapRead(0x0000);
 449   3            lock_vector=IapRead(0x0001);
 450   3            memset(buffer, 0, 16);
 451   3          }
 452   2        }
 453   1      }
 454          
 455          void loop()
 456          {
 457   1      
 458   1        key_scan();
 459   1        led_set(Dev_address);
 460   1        cmd_process();
 461   1      }
 462          
 463          void cmd_process()
 464          {
 465   1        unsigned char i;
 466   1        for (i = 0; i < BUFFER_SIZE; i++)
 467   1        {
 468   2          if (buffer[i] >= 0x80)
 469   2          {
 470   3      
 471   3            if (i < BUFFER_SIZE - 4)
 472   3              if (buffer[i + 1] == (Dev_address + 1))
 473   3                if (buffer[i + 4] == (buffer[i] ^ buffer[i + 1] ^ buffer[i + 2] ^ buffer[i + 3]))
 474   3                {
 475   4                  RS485_TX;
 476   4      
 477   4                  open_lock_cmd(i);
 478   4                  open_all_lock_cmd(i);
 479   4                  output_enable(i);
 480   4                  output_disable(i);
 481   4                  get_lock_state_cmd(i);
 482   4                  get_chipid(i);
 483   4                  get_version(i);
 484   4                  set_vector( i);
 485   4                   get_vector(i);
 486   4      
 487   4                  memset(buffer, 0, 16);
 488   4      
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 9   

 489   4                  while (busy)
 490   4                    ;
 491   4                  RS485_RX;
 492   4                }
 493   3          }
 494   2        }
 495   1      }
 496          
 497          void open_lock_cmd(unsigned char i)
 498          {
 499   1        if (buffer[i] != 0x8A)
 500   1          return;
 501   1        Drain_set(buffer[i + 2] - 1, 1);
 502   1        delay(400);
 503   1        Drain_set(buffer[i + 2] - 1, 0);
 504   1        delay(100);
 505   1      
 506   1        UartSend(0x8A);
 507   1        UartSend(buffer[i + 1]);
 508   1        UartSend(buffer[i + 2]);
 509   1        if (feedback_read(buffer[i + 2] - 1))
 510   1        {
 511   2          UartSend(0x11);
 512   2          UartSend(0x8A ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x11);
 513   2        }
 514   1        else
 515   1        {
 516   2          UartSend(0x00);
 517   2          UartSend(0x8A ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x00);
 518   2        }
 519   1      }
 520          
 521          void open_all_lock_key()
 522          {
 523   1        for (j = 0; j < CH_MAX; j++)
 524   1        {
 525   2          // Drain_set(j, 1);
 526   2          // open_lock_timer=0;
 527   2          // while ((!feedback_read(j))&&open_lock_timer<500);
 528   2          // Drain_set(j, 0);
 529   2          // open_lock_timer=-1;
 530   2          Drain_set(j, 1);
 531   2          delay(300);
 532   2          Drain_set(j, 0);
 533   2          delay(50);
 534   2          WDT_CONTR = 0x37;
 535   2        }
 536   1      }
 537          
 538          void open_all_lock()
 539          {
 540   1        for (j = 0; j < CH_MAX; j++)
 541   1        {
 542   2          // Drain_set(j, 1);
 543   2          // open_lock_timer=0;
 544   2          // while ((!feedback_read(j))&&open_lock_timer<500);
 545   2          // Drain_set(j, 0);
 546   2          // open_lock_timer=-1;
 547   2          Drain_set(j, 1);
 548   2          delay(300);
 549   2          Drain_set(j, 0);
 550   2          delay(50);
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 10  

 551   2          WDT_CONTR = 0x37;
 552   2        }
 553   1      }
 554          
 555          void open_all_lock_cmd(unsigned char i)
 556          {
 557   1        if (buffer[i] != 0x9D)
 558   1          return;
 559   1      
 560   1        open_all_lock();
 561   1        UartSend(0x9D);
 562   1        UartSend(buffer[i + 1]);
 563   1        get_state_buffer();
 564   1        UartSend(0x00);
 565   1        UartSend(state_buffer[2]);
 566   1        UartSend(state_buffer[1]);
 567   1        UartSend(state_buffer[0]);
 568   1        UartSend(0x9D ^ buffer[i + 1] ^ state_buffer[2] ^ state_buffer[1] ^ state_buffer[0]);
 569   1      }
 570          
 571          void output_enable(unsigned char i)
 572          {
 573   1        if (buffer[i] != 0x9A)
 574   1          return;
 575   1        Drain_set(buffer[i + 2] - 1, 1);
 576   1        delay_500ms();
 577   1        UartSend(0x9A);
 578   1        UartSend(buffer[i + 1]);
 579   1        UartSend(buffer[i + 2]);
 580   1        if (feedback_read(buffer[i + 2] - 1))
 581   1        {
 582   2          UartSend(0x11);
 583   2          UartSend(0x9A ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x11);
 584   2        }
 585   1        else
 586   1        {
 587   2          UartSend(0x00);
 588   2          UartSend(0x9A ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x00);
 589   2        }
 590   1      }
 591          
 592          void output_disable(unsigned char i)
 593          {
 594   1        if (buffer[i] != 0x9B)
 595   1          return;
 596   1        Drain_set(buffer[i + 2] - 1, 0);
 597   1        delay_500ms();
 598   1        UartSend(0x9B);
 599   1        UartSend(buffer[i + 1]);
 600   1        UartSend(buffer[i + 2]);
 601   1        if (feedback_read(buffer[i + 2] - 1))
 602   1        {
 603   2          UartSend(0x11);
 604   2          UartSend(0x9B ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x11);
 605   2        }
 606   1        else
 607   1        {
 608   2          UartSend(0x00);
 609   2          UartSend(0x9B ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x00);
 610   2        }
 611   1      }
 612          
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 11  

 613          void get_lock_state_cmd(unsigned char i)
 614          {
 615   1        if (buffer[i] != 0x80)
 616   1          return;
 617   1        Delay1ms();
 618   1        if (buffer[i + 2] == 0x00)
 619   1        {
 620   2          UartSend(0x80);
 621   2          UartSend(buffer[i + 1]);
 622   2          get_state_buffer();
 623   2          UartSend(state_buffer[2]);
 624   2          UartSend(state_buffer[1]);
 625   2          UartSend(state_buffer[0]);
 626   2          UartSend(0x33);
 627   2          UartSend(0x80 ^ buffer[i + 1] ^ state_buffer[2] ^ state_buffer[1] ^ state_buffer[0] ^ 0x33);
 628   2        }
 629   1        else
 630   1        {
 631   2          UartSend(0x80);
 632   2          UartSend(buffer[i + 1]);
 633   2          UartSend(buffer[i + 2]);
 634   2          if (feedback_read(buffer[i + 2] - 1))
 635   2          {
 636   3            UartSend(0x11);
 637   3            UartSend(0x80 ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x11);
 638   3          }
 639   2          else
 640   2          {
 641   3            UartSend(0x00);
 642   3            UartSend(0x80 ^ buffer[i + 1] ^ buffer[i + 2] ^ 0x00);
 643   3          }
 644   2        }
 645   1      }
 646          
 647          void get_chipid(unsigned char i)
 648          {
 649   1      
 650   1        if (buffer[i] != 0xDD)
 651   1          return;
 652   1        Delay1ms();
 653   1        Delay1ms();
 654   1        UartSend(0xDD);
 655   1        UartSend(buffer[i + 1]);
 656   1        UartSend(buffer[i + 2]);
 657   1        UartSend(CHIPID0);
 658   1        UartSend(CHIPID1);
 659   1        UartSend(CHIPID2);
 660   1        UartSend(CHIPID3);
 661   1        UartSend(CHIPID4);
 662   1        UartSend(CHIPID5);
 663   1        UartSend(CHIPID6);
 664   1        UartSend(0xDD^buffer[i + 1]^buffer[i + 2]^CHIPID0^CHIPID1^CHIPID2^CHIPID3^CHIPID4^CHIPID5^CHIPID6);
 665   1      
 666   1      }
 667          
 668          void get_version(unsigned char i)
 669          {
 670   1      
 671   1        if (buffer[i] != 0xDE)
 672   1          return;
 673   1        Delay1ms();
 674   1        Delay1ms();
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 12  

 675   1        UartSend(0xDE);
 676   1        UartSend(buffer[i + 1]);
 677   1        UartSend(VERSION_H);
 678   1        UartSend(VERSION_L);
 679   1        UartSend(0xDE^buffer[i + 1]^VERSION_H^VERSION_L);
 680   1      
 681   1      }
 682          
 683          void set_vector(unsigned char i)
 684          {
 685   1      
 686   1        if (buffer[i] != 0xDF)
 687   1          return;
 688   1        Delay1ms();
 689   1        Delay1ms();
 690   1      
 691   1        IapErase(0x0000);
 692   1        IapProgram(0x0000, Dev_address);
 693   1        IapProgram(0x0001, buffer[i+3]);
 694   1        Dev_address = IapRead(0x0000);
 695   1          lock_vector =  IapRead(0x0001);
 696   1      
 697   1        UartSend(0xDF);
 698   1        UartSend(buffer[i + 1]);
 699   1        UartSend(0x11);
 700   1        UartSend(0x11);
 701   1        UartSend(0xDF^buffer[i + 1]^0x11^0x11);
 702   1      
 703   1      }
 704          
 705          void get_vector(unsigned char i)
 706          {
 707   1      
 708   1        if (buffer[i] != 0xE1)
 709   1          return;
 710   1        Delay1ms();
 711   1        Delay1ms();
 712   1        UartSend(0xE1);
 713   1        UartSend(buffer[i + 1]);
 714   1        UartSend(buffer[i + 2]);
 715   1        UartSend(lock_vector);
 716   1        UartSend(0xE1^buffer[i + 1]^buffer[i + 2]^lock_vector);
 717   1      
 718   1      }
 719          
 720          void IapIdle()
 721          {
 722   1        IAP_CONTR = 0;    // 关闭IAP功能
 723   1        IAP_CMD = 0;    // 清除命令寄存器
 724   1        IAP_TRIG = 0;   // 清除触发寄存器
 725   1        IAP_ADDRH = 0x80; // 将地址设置到非IAP区域
 726   1        IAP_ADDRL = 0;
 727   1      }
 728          
 729          char IapRead(int addr)
 730          {
 731   1        char dat;
 732   1      
 733   1        IAP_CONTR = 0x80;    // 使能IAP
 734   1        IAP_TPS = 12;      // 设置等待参数12MHz
 735   1        IAP_CMD = 1;       // 设置IAP读命令
 736   1        IAP_ADDRL = addr;    // 设置IAP低地址
C51 COMPILER V9.60.7.0   BOX_BSP                                                           10/29/2025 01:57:07 PAGE 13  

 737   1        IAP_ADDRH = addr >> 8; // 设置IAP高地址
 738   1        IAP_TRIG = 0x5a;     // 写触发命令(0x5a)
 739   1        IAP_TRIG = 0xa5;     // 写触发命令(0xa5)
 740   1        _nop_();
 741   1        dat = IAP_DATA; // 读IAP数据
 742   1        IapIdle();    // 关闭IAP功能
 743   1        return dat;
 744   1      }
 745          
 746          void IapProgram(int addr, char dat)
 747          {
 748   1        IAP_CONTR = 0x80;    // 使能IAP
 749   1        IAP_TPS = 12;      // 设置等待参数12MHz
 750   1        IAP_CMD = 2;       // 设置IAP写命令
 751   1        IAP_ADDRL = addr;    // 设置IAP低地址
 752   1        IAP_ADDRH = addr >> 8; // 设置IAP高地址
 753   1        IAP_DATA = dat;      // 写IAP数据
 754   1        IAP_TRIG = 0x5a;     // 写触发命令(0x5a)
 755   1        IAP_TRIG = 0xa5;     // 写触发命令(0xa5)
 756   1        _nop_();
 757   1        IapIdle(); // 关闭IAP功能
 758   1      }
 759          
 760          void IapErase(int addr)
 761          {
 762   1        IAP_CONTR = 0x80;    // 使能IAP
 763   1        IAP_TPS = 12;      // 设置等待参数12MHz
 764   1        IAP_CMD = 3;       // 设置IAP擦除命令
 765   1        IAP_ADDRL = addr;    // 设置IAP低地址
 766   1        IAP_ADDRH = addr >> 8; // 设置IAP高地址
 767   1        IAP_TRIG = 0x5a;     // 写触发命令(0x5a)
 768   1        IAP_TRIG = 0xa5;     // 写触发命令(0xa5)
 769   1        _nop_();         //
 770   1        IapIdle();         // 关闭IAP功能
 771   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2283    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
